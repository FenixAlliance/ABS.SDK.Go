/*
InvoicingService

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.1.4089
Contact: support@fenix-alliance.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InvoicesAPIService InvoicesAPI service
type InvoicesAPIService service

type ApiApiV2InvoicingServiceInvoicesCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
}

func (r ApiApiV2InvoicingServiceInvoicesCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesCountGet Method for ApiV2InvoicingServiceInvoicesCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesCountGet(ctx context.Context) ApiApiV2InvoicingServiceInvoicesCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesCountGetExecute(r ApiApiV2InvoicingServiceInvoicesCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/Count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	requestBody *[]string
	currencyId *string
}

func (r ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest) RequestBody(requestBody []string) ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest) CurrencyId(currencyId string) ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest) Execute() (*MoneyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesDiscountsAggregatePostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesDiscountsAggregatePost Method for ApiV2InvoicingServiceInvoicesDiscountsAggregatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesDiscountsAggregatePost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest {
	return ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesDiscountsAggregatePostExecute(r ApiApiV2InvoicingServiceInvoicesDiscountsAggregatePostRequest) (*MoneyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesDiscountsAggregatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/DiscountsAggregate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyId", r.currencyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
}

func (r ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesExtendedCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesExtendedCountGet Method for ApiV2InvoicingServiceInvoicesExtendedCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesExtendedCountGet(ctx context.Context) ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesExtendedCountGetExecute(r ApiApiV2InvoicingServiceInvoicesExtendedCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesExtendedCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/Extended/Count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesExtendedGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
}

func (r ApiApiV2InvoicingServiceInvoicesExtendedGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesExtendedGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesExtendedGetRequest) Execute() (*ExtendedInvoiceDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesExtendedGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesExtendedGet Method for ApiV2InvoicingServiceInvoicesExtendedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesExtendedGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesExtendedGet(ctx context.Context) ApiApiV2InvoicingServiceInvoicesExtendedGetRequest {
	return ApiApiV2InvoicingServiceInvoicesExtendedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtendedInvoiceDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesExtendedGetExecute(r ApiApiV2InvoicingServiceInvoicesExtendedGetRequest) (*ExtendedInvoiceDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedInvoiceDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesExtendedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/Extended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
}

func (r ApiApiV2InvoicingServiceInvoicesGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesGetRequest) Execute() (*InvoiceDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesGet Method for ApiV2InvoicingServiceInvoicesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesGet(ctx context.Context) ApiApiV2InvoicingServiceInvoicesGetRequest {
	return ApiApiV2InvoicingServiceInvoicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InvoiceDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesGetExecute(r ApiApiV2InvoicingServiceInvoicesGetRequest) (*InvoiceDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	requestBody *[]string
	currencyId *string
}

func (r ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest) RequestBody(requestBody []string) ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest) CurrencyId(currencyId string) ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest) Execute() (*MoneyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost Method for ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest {
	return ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostExecute(r ApiApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePostRequest) (*MoneyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesGlobalSurchargesAggregatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/GlobalSurchargesAggregate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyId", r.currencyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest) Execute() (*InvoiceAdjustmentDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceAdjustmentDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGetRequest) (*InvoiceAdjustmentDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAdjustmentDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceAdjustmentId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceAdjustmentId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete(ctx context.Context, invoiceId string, invoiceAdjustmentId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceAdjustmentId: invoiceAdjustmentId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceAdjustmentId"+"}", url.PathEscape(parameterValueToString(r.invoiceAdjustmentId, "invoiceAdjustmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceAdjustmentId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest) Execute() (*InvoiceAdjustmentDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceAdjustmentId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet(ctx context.Context, invoiceId string, invoiceAdjustmentId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceAdjustmentId: invoiceAdjustmentId,
	}
}

// Execute executes the request
//  @return InvoiceAdjustmentDtoEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGetRequest) (*InvoiceAdjustmentDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceAdjustmentDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceAdjustmentId"+"}", url.PathEscape(parameterValueToString(r.invoiceAdjustmentId, "invoiceAdjustmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceAdjustmentId string
	invoiceAdjustmentUpdateDto *InvoiceAdjustmentUpdateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest) InvoiceAdjustmentUpdateDto(invoiceAdjustmentUpdateDto InvoiceAdjustmentUpdateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest {
	r.invoiceAdjustmentUpdateDto = &invoiceAdjustmentUpdateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceAdjustmentId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut(ctx context.Context, invoiceId string, invoiceAdjustmentId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceAdjustmentId: invoiceAdjustmentId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsInvoiceAdjustmentIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments/{invoiceAdjustmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceAdjustmentId"+"}", url.PathEscape(parameterValueToString(r.invoiceAdjustmentId, "invoiceAdjustmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceAdjustmentUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceAdjustmentCreateDto *InvoiceAdjustmentCreateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest) InvoiceAdjustmentCreateDto(invoiceAdjustmentCreateDto InvoiceAdjustmentCreateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest {
	r.invoiceAdjustmentCreateDto = &invoiceAdjustmentCreateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost Method for ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdAdjustmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Adjustments"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceAdjustmentCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePut Method for ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePut(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdCalculatePutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdCalculatePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Calculate"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdDeleteExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdDelete Method for ApiV2InvoicingServiceInvoicesInvoiceIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdDelete(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdDeleteExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest) Execute() (*InvoiceDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceDtoEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdExtendedGetRequest) (*InvoiceDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdExtendedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Extended"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	itemId *string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest) ItemId(itemId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest {
	r.itemId = &itemId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest) Execute() (*InvoiceLineDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceLineDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesGetRequest) (*InvoiceLineDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceLineDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.itemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdCalculatePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Calculate"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest) Execute() (*InvoiceLineDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return InvoiceLineDtoEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGetRequest) (*InvoiceLineDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceLineDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
	invoiceLineUpdateDto *InvoiceLineUpdateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest) InvoiceLineUpdateDto(invoiceLineUpdateDto InvoiceLineUpdateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest {
	r.invoiceLineUpdateDto = &invoiceLineUpdateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceLineUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest) Execute() (*InvoiceLineAppliedTaxDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return InvoiceLineAppliedTaxDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGetRequest) (*InvoiceLineAppliedTaxDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceLineAppliedTaxDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
	invoiceLineTaxId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @param invoiceLineTaxId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete(ctx context.Context, invoiceId string, invoiceLineId string, invoiceLineTaxId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
		invoiceLineTaxId: invoiceLineTaxId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/{invoiceLineTaxId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineTaxId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineTaxId, "invoiceLineTaxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
	invoiceLineTaxId string
	invoiceLineAppliedTaxUpdateDto *InvoiceLineAppliedTaxUpdateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest) InvoiceLineAppliedTaxUpdateDto(invoiceLineAppliedTaxUpdateDto InvoiceLineAppliedTaxUpdateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest {
	r.invoiceLineAppliedTaxUpdateDto = &invoiceLineAppliedTaxUpdateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @param invoiceLineTaxId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut(ctx context.Context, invoiceId string, invoiceLineId string, invoiceLineTaxId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
		invoiceLineTaxId: invoiceLineTaxId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesInvoiceLineTaxIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes/{invoiceLineTaxId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineTaxId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineTaxId, "invoiceLineTaxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceLineAppliedTaxUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineId string
	invoiceLineAppliedTaxCreateDto *InvoiceLineAppliedTaxCreateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest) InvoiceLineAppliedTaxCreateDto(invoiceLineAppliedTaxCreateDto InvoiceLineAppliedTaxCreateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest {
	r.invoiceLineAppliedTaxCreateDto = &invoiceLineAppliedTaxCreateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceLineId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost(ctx context.Context, invoiceId string, invoiceLineId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceLineId: invoiceLineId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesInvoiceLineIdTaxesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines/{invoiceLineId}/Taxes"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLineId"+"}", url.PathEscape(parameterValueToString(r.invoiceLineId, "invoiceLineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceLineAppliedTaxCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceLineCreateDto *InvoiceLineCreateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest) InvoiceLineCreateDto(invoiceLineCreateDto InvoiceLineCreateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest {
	r.invoiceLineCreateDto = &invoiceLineCreateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesPostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdLinesPost Method for ApiV2InvoicingServiceInvoicesInvoiceIdLinesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesPost(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdLinesPostExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdLinesPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdLinesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Lines"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceLineCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Payments/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest) Execute() (*InvoiceDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGetRequest) (*InvoiceDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdPaymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/Payments"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceUpdateDto *InvoiceUpdateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest) InvoiceUpdateDto(invoiceUpdateDto InvoiceUpdateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest {
	r.invoiceUpdateDto = &invoiceUpdateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdPutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdPut Method for ApiV2InvoicingServiceInvoicesInvoiceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPut(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdPutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest) Execute() (*InvoiceReferenceDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGet(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceReferenceDtoListEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesGetRequest) (*InvoiceReferenceDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceReferenceDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceReferenceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceReferenceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete(ctx context.Context, invoiceId string, invoiceReferenceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceReferenceId: invoiceReferenceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceReferenceId"+"}", url.PathEscape(parameterValueToString(r.invoiceReferenceId, "invoiceReferenceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceReferenceId string
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest) Execute() (*InvoiceReferenceDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceReferenceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet(ctx context.Context, invoiceId string, invoiceReferenceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceReferenceId: invoiceReferenceId,
	}
}

// Execute executes the request
//  @return InvoiceReferenceDtoEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGetRequest) (*InvoiceReferenceDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceReferenceDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceReferenceId"+"}", url.PathEscape(parameterValueToString(r.invoiceReferenceId, "invoiceReferenceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceReferenceId string
	invoiceReferenceUpdateDto *InvoiceReferenceUpdateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest) InvoiceReferenceUpdateDto(invoiceReferenceUpdateDto InvoiceReferenceUpdateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest {
	r.invoiceReferenceUpdateDto = &invoiceReferenceUpdateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @param invoiceReferenceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut(ctx context.Context, invoiceId string, invoiceReferenceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		invoiceReferenceId: invoiceReferenceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesInvoiceReferenceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References/{invoiceReferenceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceReferenceId"+"}", url.PathEscape(parameterValueToString(r.invoiceReferenceId, "invoiceReferenceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceReferenceUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
	invoiceReferenceCreateDto *InvoiceReferenceCreateDto
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest) InvoiceReferenceCreateDto(invoiceReferenceCreateDto InvoiceReferenceCreateDto) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest {
	r.invoiceReferenceCreateDto = &invoiceReferenceCreateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPost Method for ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPost(ctx context.Context, invoiceId string) ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest {
	return ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostExecute(r ApiApiV2InvoicingServiceInvoicesInvoiceIdReferencesPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesInvoiceIdReferencesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}/References"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceReferenceCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesPostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceCreateDto *InvoiceCreateDto
}

func (r ApiApiV2InvoicingServiceInvoicesPostRequest) TenantId(tenantId string) ApiApiV2InvoicingServiceInvoicesPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesPostRequest) InvoiceCreateDto(invoiceCreateDto InvoiceCreateDto) ApiApiV2InvoicingServiceInvoicesPostRequest {
	r.invoiceCreateDto = &invoiceCreateDto
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesPostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesPost Method for ApiV2InvoicingServiceInvoicesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesPostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesPost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesPostRequest {
	return ApiApiV2InvoicingServiceInvoicesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesPostExecute(r ApiApiV2InvoicingServiceInvoicesPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	requestBody *[]string
	currencyId *string
}

func (r ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest) RequestBody(requestBody []string) ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest) CurrencyId(currencyId string) ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest) Execute() (*MoneyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesTaxBasesAggregatePostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesTaxBasesAggregatePost Method for ApiV2InvoicingServiceInvoicesTaxBasesAggregatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTaxBasesAggregatePost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest {
	return ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTaxBasesAggregatePostExecute(r ApiApiV2InvoicingServiceInvoicesTaxBasesAggregatePostRequest) (*MoneyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesTaxBasesAggregatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/TaxBasesAggregate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyId", r.currencyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	requestBody *[]string
	currencyId *string
}

func (r ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest) RequestBody(requestBody []string) ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest) CurrencyId(currencyId string) ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest) Execute() (*MoneyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesTaxesAggregatePostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesTaxesAggregatePost Method for ApiV2InvoicingServiceInvoicesTaxesAggregatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTaxesAggregatePost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest {
	return ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTaxesAggregatePostExecute(r ApiApiV2InvoicingServiceInvoicesTaxesAggregatePostRequest) (*MoneyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesTaxesAggregatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/TaxesAggregate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyId", r.currencyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	requestBody *[]string
	currencyId *string
}

func (r ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest) RequestBody(requestBody []string) ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest) CurrencyId(currencyId string) ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest) Execute() (*MoneyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2InvoicingServiceInvoicesTotalsAggregatePostExecute(r)
}

/*
ApiV2InvoicingServiceInvoicesTotalsAggregatePost Method for ApiV2InvoicingServiceInvoicesTotalsAggregatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest
*/
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTotalsAggregatePost(ctx context.Context) ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest {
	return ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoneyEnvelope
func (a *InvoicesAPIService) ApiV2InvoicingServiceInvoicesTotalsAggregatePostExecute(r ApiApiV2InvoicingServiceInvoicesTotalsAggregatePostRequest) (*MoneyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoneyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ApiV2InvoicingServiceInvoicesTotalsAggregatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/TotalsAggregate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyId", r.currencyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAsyncRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	tenantId *string
	invoiceId string
}

func (r ApiGetInvoiceAsyncRequest) TenantId(tenantId string) ApiGetInvoiceAsyncRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiGetInvoiceAsyncRequest) Execute() (*InvoiceDtoEnvelope, *http.Response, error) {
	return r.ApiService.GetInvoiceAsyncExecute(r)
}

/*
GetInvoiceAsync Method for GetInvoiceAsync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId
 @return ApiGetInvoiceAsyncRequest
*/
func (a *InvoicesAPIService) GetInvoiceAsync(ctx context.Context, invoiceId string) ApiGetInvoiceAsyncRequest {
	return ApiGetInvoiceAsyncRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return InvoiceDtoEnvelope
func (a *InvoicesAPIService) GetInvoiceAsyncExecute(r ApiGetInvoiceAsyncRequest) (*InvoiceDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.GetInvoiceAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/InvoicingService/Invoices/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

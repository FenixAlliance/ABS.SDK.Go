/*
ProjectsService

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.1.4089
Contact: support@fenix-alliance.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProjectsAPIService ProjectsAPI service
type ProjectsAPIService service

type ApiApiV2ProjectsServiceProjectsCountGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsCountGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsCountGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsCountGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsCountGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsCountGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsCountGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsCountGet Method for ApiV2ProjectsServiceProjectsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2ProjectsServiceProjectsCountGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsCountGet(ctx context.Context) ApiApiV2ProjectsServiceProjectsCountGetRequest {
	return ApiApiV2ProjectsServiceProjectsCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsCountGetExecute(r ApiApiV2ProjectsServiceProjectsCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/Count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsGetRequest) Execute() (*ProjectDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsGet Method for ApiV2ProjectsServiceProjectsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2ProjectsServiceProjectsGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsGet(ctx context.Context) ApiApiV2ProjectsServiceProjectsGetRequest {
	return ApiApiV2ProjectsServiceProjectsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProjectDtoListEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsGetExecute(r ApiApiV2ProjectsServiceProjectsGetRequest) (*ProjectDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsPostRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectCreateDto *ProjectCreateDto
}

func (r ApiApiV2ProjectsServiceProjectsPostRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsPostRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsPostRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsPostRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsPostRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsPostRequest) ProjectCreateDto(projectCreateDto ProjectCreateDto) ApiApiV2ProjectsServiceProjectsPostRequest {
	r.projectCreateDto = &projectCreateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsPostExecute(r)
}

/*
ApiV2ProjectsServiceProjectsPost Method for ApiV2ProjectsServiceProjectsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2ProjectsServiceProjectsPostRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsPost(ctx context.Context) ApiApiV2ProjectsServiceProjectsPostRequest {
	return ApiApiV2ProjectsServiceProjectsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsPostExecute(r ApiApiV2ProjectsServiceProjectsPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdDeleteExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdDelete Method for ApiV2ProjectsServiceProjectsProjectIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdDelete(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdDeleteExecute(r ApiApiV2ProjectsServiceProjectsProjectIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdGetRequest) Execute() (*ProjectDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdGet Method for ApiV2ProjectsServiceProjectsProjectIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectDtoEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdGetRequest) (*ProjectDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectPeriodCreateDto *ProjectPeriodCreateDto
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) ProjectPeriodCreateDto(projectPeriodCreateDto ProjectPeriodCreateDto) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest {
	r.projectPeriodCreateDto = &projectPeriodCreateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdPeriodsGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdPeriodsGet Method for ApiV2ProjectsServiceProjectsProjectIdPeriodsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsGetRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdPeriodsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Periods"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectPeriodCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	projectPeriodId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDelete Method for ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param projectPeriodId
 @return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDelete(ctx context.Context, projectId string, projectPeriodId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		projectPeriodId: projectPeriodId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteExecute(r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Periods/{projectPeriodId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectPeriodId"+"}", url.PathEscape(parameterValueToString(r.projectPeriodId, "projectPeriodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	projectPeriodId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectPeriodUpdateDto *ProjectPeriodUpdateDto
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) ProjectPeriodUpdateDto(projectPeriodUpdateDto ProjectPeriodUpdateDto) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest {
	r.projectPeriodUpdateDto = &projectPeriodUpdateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPut Method for ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param projectPeriodId
 @return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPut(ctx context.Context, projectId string, projectPeriodId string) ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		projectPeriodId: projectPeriodId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutExecute(r ApiApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdPeriodsProjectPeriodIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Periods/{projectPeriodId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectPeriodId"+"}", url.PathEscape(parameterValueToString(r.projectPeriodId, "projectPeriodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectPeriodUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdPutRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectUpdateDto *ProjectUpdateDto
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPutRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdPutRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) ProjectUpdateDto(projectUpdateDto ProjectUpdateDto) ApiApiV2ProjectsServiceProjectsProjectIdPutRequest {
	r.projectUpdateDto = &projectUpdateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdPutExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdPut Method for ApiV2ProjectsServiceProjectsProjectIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdPutRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPut(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdPutRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdPutExecute(r ApiApiV2ProjectsServiceProjectsProjectIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGet Method for ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/TaskCategories/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest) Execute() (*TaskCategoryDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGet Method for ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return TaskCategoryDtoListEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGetRequest) (*TaskCategoryDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskCategoryDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTaskCategoriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/TaskCategories"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTasksCountGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTasksCountGet Method for ApiV2ProjectsServiceProjectsProjectIdTasksCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksCountGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksCountGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTasksCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTasksCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Tasks/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest) Execute() (*ProjectTaskDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTasksGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTasksGet Method for ApiV2ProjectsServiceProjectsProjectIdTasksGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectTaskDtoListEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTasksGetRequest) (*ProjectTaskDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectTaskDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectTaskCreateDto *ProjectTaskCreateDto
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) ProjectTaskCreateDto(projectTaskCreateDto ProjectTaskCreateDto) ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest {
	r.projectTaskCreateDto = &projectTaskCreateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTasksPostExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTasksPost Method for ApiV2ProjectsServiceProjectsProjectIdTasksPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksPost(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksPostExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTasksPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTasksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectTaskCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	tenantId *string
	projectId string
	projectTaskId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDelete Method for ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param projectTaskId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDelete(ctx context.Context, projectId string, projectTaskId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		projectTaskId: projectTaskId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Tasks/{projectTaskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectTaskId"+"}", url.PathEscape(parameterValueToString(r.projectTaskId, "projectTaskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	projectTaskId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
	projectTaskUpdateDto *ProjectTaskUpdateDto
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) ProjectTaskUpdateDto(projectTaskUpdateDto ProjectTaskUpdateDto) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest {
	r.projectTaskUpdateDto = &projectTaskUpdateDto
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPut Method for ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @param projectTaskId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPut(ctx context.Context, projectId string, projectTaskId string) ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		projectTaskId: projectTaskId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTasksProjectTaskIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/Tasks/{projectTaskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectTaskId"+"}", url.PathEscape(parameterValueToString(r.projectTaskId, "projectTaskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.projectTaskUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGet Method for ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTimeLogsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/TimeLogs/Count"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	projectId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest) TenantId(tenantId string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest) ApiVersion(apiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest) XApiVersion(xApiVersion string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest) Execute() (*ProjectTimeLogDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2ProjectsServiceProjectsProjectIdTimeLogsGetExecute(r)
}

/*
ApiV2ProjectsServiceProjectsProjectIdTimeLogsGet Method for ApiV2ProjectsServiceProjectsProjectIdTimeLogsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId
 @return ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest
*/
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTimeLogsGet(ctx context.Context, projectId string) ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest {
	return ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectTimeLogDtoListEnvelope
func (a *ProjectsAPIService) ApiV2ProjectsServiceProjectsProjectIdTimeLogsGetExecute(r ApiApiV2ProjectsServiceProjectsProjectIdTimeLogsGetRequest) (*ProjectTimeLogDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectTimeLogDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ApiV2ProjectsServiceProjectsProjectIdTimeLogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/ProjectsService/Projects/{projectId}/TimeLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tenantId == nil {
		return localVarReturnValue, nil, reportError("tenantId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SupportService

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.1.4089
Contact: support@fenix-alliance.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SupportTicketsAPIService SupportTicketsAPI service
type SupportTicketsAPIService service

type ApiApiV2SupportServiceSupportTicketsCountGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsCountGetRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsCountGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsCountGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsCountGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsCountGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsCountGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsCountGetRequest) Execute() (*Int32Envelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsCountGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsCountGet Method for ApiV2SupportServiceSupportTicketsCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2SupportServiceSupportTicketsCountGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsCountGet(ctx context.Context) ApiApiV2SupportServiceSupportTicketsCountGetRequest {
	return ApiApiV2SupportServiceSupportTicketsCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Int32Envelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsCountGetExecute(r ApiApiV2SupportServiceSupportTicketsCountGetRequest) (*Int32Envelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int32Envelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/Count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsGetRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsGetRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsGetRequest) Execute() (*SupportTicketDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsGet Method for ApiV2SupportServiceSupportTicketsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2SupportServiceSupportTicketsGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsGet(ctx context.Context) ApiApiV2SupportServiceSupportTicketsGetRequest {
	return ApiApiV2SupportServiceSupportTicketsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportTicketDtoListEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsGetExecute(r ApiApiV2SupportServiceSupportTicketsGetRequest) (*SupportTicketDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportTicketDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsPostRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketCreateDto *SupportTicketCreateDto
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsPostRequest) SupportTicketCreateDto(supportTicketCreateDto SupportTicketCreateDto) ApiApiV2SupportServiceSupportTicketsPostRequest {
	r.supportTicketCreateDto = &supportTicketCreateDto
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsPostRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsPostRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsPostRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsPostRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsPostRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsPostExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsPost Method for ApiV2SupportServiceSupportTicketsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2SupportServiceSupportTicketsPostRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsPost(ctx context.Context) ApiApiV2SupportServiceSupportTicketsPostRequest {
	return ApiApiV2SupportServiceSupportTicketsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsPostExecute(r ApiApiV2SupportServiceSupportTicketsPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.supportTicketCreateDto == nil {
		return localVarReturnValue, nil, reportError("supportTicketCreateDto is required and must be specified")
	}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.supportTicketCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest) Execute() (*SupportTicketConversationDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGet Method for ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGet(ctx context.Context, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return SupportTicketConversationDtoListEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGetRequest) (*SupportTicketConversationDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportTicketConversationDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}/Conversations"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	supportTicketConversationCreateDto *SupportTicketConversationCreateDto
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) SupportTicketConversationCreateDto(supportTicketConversationCreateDto SupportTicketConversationCreateDto) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest {
	r.supportTicketConversationCreateDto = &supportTicketConversationCreateDto
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPost Method for ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPost(ctx context.Context, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPostRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}/Conversations"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.supportTicketConversationCreateDto == nil {
		return localVarReturnValue, nil, reportError("supportTicketConversationCreateDto is required and must be specified")
	}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.supportTicketConversationCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	supportTicketConversationId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDelete Method for ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @param supportTicketConversationId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDelete(ctx context.Context, supportTicketId string, supportTicketConversationId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
		supportTicketConversationId: supportTicketConversationId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}/Conversations/{supportTicketConversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketConversationId"+"}", url.PathEscape(parameterValueToString(r.supportTicketConversationId, "supportTicketConversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	supportTicketConversationId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest) Execute() (*SupportTicketConversationDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGet Method for ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @param supportTicketConversationId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGet(ctx context.Context, supportTicketId string, supportTicketConversationId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
		supportTicketConversationId: supportTicketConversationId,
	}
}

// Execute executes the request
//  @return SupportTicketConversationDtoEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGetRequest) (*SupportTicketConversationDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportTicketConversationDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}/Conversations/{supportTicketConversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketConversationId"+"}", url.PathEscape(parameterValueToString(r.supportTicketConversationId, "supportTicketConversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketConversationId string
	supportTicketId string
	pageNumber *int32
	pageSize *int32
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) PageNumber(pageNumber int32) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) PageSize(pageSize int32) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) Execute() (*PrivateMessageDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGet Method for ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketConversationId
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGet(ctx context.Context, supportTicketConversationId string, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketConversationId: supportTicketConversationId,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return PrivateMessageDtoListEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGetRequest) (*PrivateMessageDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrivateMessageDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdConversationsSupportTicketConversationIdMessagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}/Conversations/{supportTicketConversationId}/Messages"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketConversationId"+"}", url.PathEscape(parameterValueToString(r.supportTicketConversationId, "supportTicketConversationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdDeleteExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdDelete Method for ApiV2SupportServiceSupportTicketsSupportTicketIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdDelete(ctx context.Context, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdDeleteExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdDeleteRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest) Execute() (*SupportTicketDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdGetExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdGet Method for ApiV2SupportServiceSupportTicketsSupportTicketIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdGet(ctx context.Context, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return SupportTicketDtoEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdGetExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdGetRequest) (*SupportTicketDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportTicketDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest struct {
	ctx context.Context
	ApiService *SupportTicketsAPIService
	supportTicketId string
	supportTicketUpdateDto *SupportTicketUpdateDto
	tenantId *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) SupportTicketUpdateDto(supportTicketUpdateDto SupportTicketUpdateDto) ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest {
	r.supportTicketUpdateDto = &supportTicketUpdateDto
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) TenantId(tenantId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) ApiVersion(apiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) XApiVersion(xApiVersion string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) Execute() (*EmptyEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2SupportServiceSupportTicketsSupportTicketIdPutExecute(r)
}

/*
ApiV2SupportServiceSupportTicketsSupportTicketIdPut Method for ApiV2SupportServiceSupportTicketsSupportTicketIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param supportTicketId
 @return ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest
*/
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdPut(ctx context.Context, supportTicketId string) ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest {
	return ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest{
		ApiService: a,
		ctx: ctx,
		supportTicketId: supportTicketId,
	}
}

// Execute executes the request
//  @return EmptyEnvelope
func (a *SupportTicketsAPIService) ApiV2SupportServiceSupportTicketsSupportTicketIdPutExecute(r ApiApiV2SupportServiceSupportTicketsSupportTicketIdPutRequest) (*EmptyEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SupportTicketsAPIService.ApiV2SupportServiceSupportTicketsSupportTicketIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/SupportService/SupportTickets/{supportTicketId}"
	localVarPath = strings.Replace(localVarPath, "{"+"supportTicketId"+"}", url.PathEscape(parameterValueToString(r.supportTicketId, "supportTicketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.supportTicketUpdateDto == nil {
		return localVarReturnValue, nil, reportError("supportTicketUpdateDto is required and must be specified")
	}

	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.supportTicketUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

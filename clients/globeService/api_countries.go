/*
GlobeService

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.1.4089
Contact: support@fenix-alliance.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CountriesAPIService CountriesAPI service
type CountriesAPIService service

type ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest) Execute() (*CountryCallingCodeDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdCallingCodesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdCallingCodesGet Method for ApiV2GlobeServiceCountriesCountryIdCallingCodesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdCallingCodesGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CountryCallingCodeDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdCallingCodesGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdCallingCodesGetRequest) (*CountryCallingCodeDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryCallingCodeDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdCallingCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/CallingCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest) Execute() (*CurrencyDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdCurrenciesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdCurrenciesGet Method for ApiV2GlobeServiceCountriesCountryIdCurrenciesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdCurrenciesGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CurrencyDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdCurrenciesGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdCurrenciesGetRequest) (*CurrencyDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrencyDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdCurrenciesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/Currencies"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdGetRequest) Execute() (*CountryDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdGet Method for ApiV2GlobeServiceCountriesCountryIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CountryDtoEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdGetRequest) (*CountryDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryStateId string
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest) Execute() (*CityDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGet Method for ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryStateId
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGet(ctx context.Context, countryStateId string, countryId string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest{
		ApiService: a,
		ctx: ctx,
		countryStateId: countryStateId,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CityDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGetRequest) (*CityDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CityDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdCitiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/States/{countryStateId}/Cities"
	localVarPath = strings.Replace(localVarPath, "{"+"countryStateId"+"}", url.PathEscape(parameterValueToString(r.countryStateId, "countryStateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryStateId string
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest) Execute() (*CountryStateDtoEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGet Method for ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryStateId
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGet(ctx context.Context, countryStateId string, countryId string) ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest{
		ApiService: a,
		ctx: ctx,
		countryStateId: countryStateId,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CountryStateDtoEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGetRequest) (*CountryStateDtoEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryStateDtoEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdStatesCountryStateIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/States/{countryStateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"countryStateId"+"}", url.PathEscape(parameterValueToString(r.countryStateId, "countryStateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest) Execute() (*CountryStateDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdStatesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdStatesGet Method for ApiV2GlobeServiceCountriesCountryIdStatesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CountryStateDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdStatesGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdStatesGetRequest) (*CountryStateDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryStateDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdStatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/States"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest) Execute() (*TimezoneDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdTimezonesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdTimezonesGet Method for ApiV2GlobeServiceCountriesCountryIdTimezonesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdTimezonesGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return TimezoneDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdTimezonesGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdTimezonesGetRequest) (*TimezoneDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimezoneDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdTimezonesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/Timezones"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryId string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest) Execute() (*CountryTopLevelDomainDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGet Method for ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param countryId
 @return ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGet(ctx context.Context, countryId string) ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest {
	return ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest{
		ApiService: a,
		ctx: ctx,
		countryId: countryId,
	}
}

// Execute executes the request
//  @return CountryTopLevelDomainDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetExecute(r ApiApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGetRequest) (*CountryTopLevelDomainDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryTopLevelDomainDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesCountryIdTopLevelDomainsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/{countryId}/TopLevelDomains"
	localVarPath = strings.Replace(localVarPath, "{"+"countryId"+"}", url.PathEscape(parameterValueToString(r.countryId, "countryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesGetRequest) Execute() (*CountryDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesGet Method for ApiV2GlobeServiceCountriesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2GlobeServiceCountriesGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesGet(ctx context.Context) ApiApiV2GlobeServiceCountriesGetRequest {
	return ApiApiV2GlobeServiceCountriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountryDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesGetExecute(r ApiApiV2GlobeServiceCountriesGetRequest) (*CountryDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2GlobeServiceCountriesSearchGetRequest struct {
	ctx context.Context
	ApiService *CountriesAPIService
	countryName *string
	apiVersion *string
	xApiVersion *string
}

func (r ApiApiV2GlobeServiceCountriesSearchGetRequest) CountryName(countryName string) ApiApiV2GlobeServiceCountriesSearchGetRequest {
	r.countryName = &countryName
	return r
}

func (r ApiApiV2GlobeServiceCountriesSearchGetRequest) ApiVersion(apiVersion string) ApiApiV2GlobeServiceCountriesSearchGetRequest {
	r.apiVersion = &apiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesSearchGetRequest) XApiVersion(xApiVersion string) ApiApiV2GlobeServiceCountriesSearchGetRequest {
	r.xApiVersion = &xApiVersion
	return r
}

func (r ApiApiV2GlobeServiceCountriesSearchGetRequest) Execute() (*CountryDtoListEnvelope, *http.Response, error) {
	return r.ApiService.ApiV2GlobeServiceCountriesSearchGetExecute(r)
}

/*
ApiV2GlobeServiceCountriesSearchGet Method for ApiV2GlobeServiceCountriesSearchGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2GlobeServiceCountriesSearchGetRequest
*/
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesSearchGet(ctx context.Context) ApiApiV2GlobeServiceCountriesSearchGetRequest {
	return ApiApiV2GlobeServiceCountriesSearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountryDtoListEnvelope
func (a *CountriesAPIService) ApiV2GlobeServiceCountriesSearchGetExecute(r ApiApiV2GlobeServiceCountriesSearchGetRequest) (*CountryDtoListEnvelope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountryDtoListEnvelope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CountriesAPIService.ApiV2GlobeServiceCountriesSearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/GlobeService/Countries/Search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.countryName == nil {
		return localVarReturnValue, nil, reportError("countryName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "countryName", r.countryName, "form", "")
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-version", r.xApiVersion, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
